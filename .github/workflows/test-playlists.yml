name: MoodTunes Playlist Tests

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'app.py'
      - 'tests/test_playlists.py'
      - 'requirements*.txt'
  pull_request:
    branches: [ main ]
    paths:
      - 'app.py'
      - 'tests/test_playlists.py'
      - 'requirements*.txt'
  schedule:
    # Run playlist validation daily at 2 AM UTC
    - cron: '0 2 * * *'

jobs:
  validate-playlists:
    name: Validate All Playlists
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
        
    - name: Run playlist validation tests
      run: |
        echo "üéµ Validating all 15 mood playlists..."
        python -m pytest tests/test_playlists.py::TestMoodPlaylists -v --tb=short
        
    - name: Run search functionality tests
      run: |
        echo "üîç Validating search functionality..."
        python -m pytest tests/test_playlists.py::TestSearchFunctionality -v --tb=short
        
    - name: Run integration tests
      run: |
        echo "üîó Running playlist integration tests..."
        python -m pytest tests/test_playlists.py::TestPlaylistIntegration -v --tb=short
        
    - name: Validate playlist accessibility
      run: |
        echo "üåê Testing playlist accessibility..."
        python -c "
        from app import mood_playlists
        import requests
        import time
        
        failed_playlists = []
        
        for mood, playlist_id in mood_playlists.items():
            url = f'https://open.spotify.com/playlist/{playlist_id}'
            try:
                response = requests.head(url, timeout=10)
                if response.status_code not in [200, 301, 302]:
                    failed_playlists.append((mood, playlist_id, response.status_code))
                    print(f'‚ùå {mood}: {url} returned {response.status_code}')
                else:
                    print(f'‚úÖ {mood}: Playlist accessible')
                time.sleep(0.5)  # Rate limiting
            except Exception as e:
                failed_playlists.append((mood, playlist_id, str(e)))
                print(f'‚ùå {mood}: Error - {e}')
        
        if failed_playlists:
            print(f'\\n‚ö†Ô∏è  {len(failed_playlists)} playlists may have issues:')
            for mood, playlist_id, error in failed_playlists:
                print(f'  - {mood} ({playlist_id}): {error}')
        else:
            print('\\nüéâ All playlists are accessible!')
        "
        
    - name: Generate playlist report
      run: |
        echo "üìä Generating playlist report..."
        python -c "
        from app import mood_playlists, mood_categories
        
        print('\\nüéµ MoodTunes Playlist Report')
        print('=' * 40)
        print(f'Total Moods: {len(mood_playlists)}')
        print(f'Total Categories: {len(mood_categories)}')
        print()
        
        for category, data in mood_categories.items():
            print(f'{data[\"icon\"]} {category.title()}: {len(data[\"moods\"])} moods')
            for mood in data['moods']:
                playlist_id = mood_playlists[mood]
                print(f'  - {mood.title()}: {playlist_id}')
            print()
        "

  mood-coverage-report:
    name: Mood Coverage Analysis
    runs-on: ubuntu-latest
    needs: validate-playlists
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Analyze mood coverage
      run: |
        echo "üìà Analyzing mood coverage and categories..."
        python -c "
        from app import mood_playlists, mood_categories, get_time_based_suggestions
        from collections import Counter
        import json
        
        # Analyze category distribution
        category_counts = {}
        for category, data in mood_categories.items():
            category_counts[category] = len(data['moods'])
        
        print('üìä Category Distribution:')
        for category, count in sorted(category_counts.items()):
            percentage = (count / len(mood_playlists)) * 100
            print(f'  {category}: {count} moods ({percentage:.1f}%)')
        
        print('\\nüïê Time-based Suggestions Coverage:')
        # Test time suggestions multiple times to see variety
        all_suggestions = []
        for hour in range(0, 24):
            # Mock different hours (this is a simplified test)
            suggestions = get_time_based_suggestions()
            all_suggestions.extend(suggestions)
        
        suggestion_counts = Counter(all_suggestions)
        print(f'Total unique moods in time suggestions: {len(suggestion_counts)}')
        for mood, count in suggestion_counts.most_common():
            print(f'  {mood}: suggested {count} times')
        
        # Coverage metrics
        time_coverage = len(suggestion_counts) / len(mood_playlists) * 100
        print(f'\\nüìà Metrics:')
        print(f'  Time suggestion coverage: {time_coverage:.1f}%')
        print(f'  Average category size: {len(mood_playlists) / len(mood_categories):.1f} moods')
        print(f'  Total playlist variety: {len(set(mood_playlists.values()))} unique playlists')
        "
        
    - name: Test search functionality coverage
      run: |
        echo "üîç Testing search functionality coverage..."
        python -c "
        from app import mood_playlists, mood_metadata
        
        print('\\nüîç Search Functionality Analysis')
        print('=' * 40)
        
        # Test keyword coverage
        total_keywords = 0
        mood_keyword_count = {}
        
        for mood_key, metadata in mood_metadata.items():
            keyword_count = len(metadata.get('keywords', []))
            mood_keyword_count[mood_key] = keyword_count
            total_keywords += keyword_count
        
        print(f'Total search keywords: {total_keywords}')
        print(f'Average keywords per mood: {total_keywords / len(mood_metadata):.1f}')
        print()
        
        # Test search scenarios
        test_scenarios = [
            ('Single result queries', ['happy', 'study', 'workout', 'meditation']),
            ('Multiple result queries', ['positive', 'calm', 'peaceful', 'inspiring']),
            ('No result queries', ['xyz123', 'coding', 'invalid'])
        ]
        
        for scenario_name, queries in test_scenarios:
            print(f'{scenario_name}:')
            for query in queries:
                matches = []
                query_lower = query.lower()
                
                for mood_key, playlist_id in mood_playlists.items():
                    mood_info = mood_metadata.get(mood_key, {})
                    
                    if (query_lower in mood_key.lower() or
                        query_lower in mood_info.get('name', '').lower() or 
                        query_lower in mood_info.get('description', '').lower() or
                        any(query_lower in keyword.lower() for keyword in mood_info.get('keywords', []))):
                        matches.append(mood_key)
                
                print(f'  {query}: {len(matches)} result(s) - {matches}')
            print()
        
        # Keyword distribution by category
        from collections import defaultdict
        category_keywords = defaultdict(int)
        
        for mood_key, metadata in mood_metadata.items():
            category = metadata.get('category', 'Other')
            category_keywords[category] += len(metadata.get('keywords', []))
        
        print('üìä Keywords by Category:')
        for category, count in sorted(category_keywords.items()):
            print(f'  {category}: {count} keywords')
        "