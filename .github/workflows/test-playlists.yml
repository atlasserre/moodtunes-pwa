name: MoodTunes Playlist Tests

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'app_production.py'
      - 'test_playlists.py'
      - 'requirements*.txt'
  pull_request:
    branches: [ main ]
    paths:
      - 'app_production.py'
      - 'test_playlists.py'
      - 'requirements*.txt'
  schedule:
    # Run playlist validation daily at 2 AM UTC
    - cron: '0 2 * * *'

jobs:
  validate-playlists:
    name: Validate All Playlists
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
        
    - name: Run playlist validation tests
      run: |
        echo "ğŸµ Validating all 15 mood playlists..."
        python -m pytest test_playlists.py::TestMoodPlaylists -v --tb=short
        
    - name: Run integration tests
      run: |
        echo "ğŸ”— Running playlist integration tests..."
        python -m pytest test_playlists.py::TestPlaylistIntegration -v --tb=short
        
    - name: Validate playlist accessibility
      run: |
        echo "ğŸŒ Testing playlist accessibility..."
        python -c "
        from app_production import mood_playlists
        import requests
        import time
        
        failed_playlists = []
        
        for mood, playlist_id in mood_playlists.items():
            url = f'https://open.spotify.com/playlist/{playlist_id}'
            try:
                response = requests.head(url, timeout=10)
                if response.status_code not in [200, 301, 302]:
                    failed_playlists.append((mood, playlist_id, response.status_code))
                    print(f'âŒ {mood}: {url} returned {response.status_code}')
                else:
                    print(f'âœ… {mood}: Playlist accessible')
                time.sleep(0.5)  # Rate limiting
            except Exception as e:
                failed_playlists.append((mood, playlist_id, str(e)))
                print(f'âŒ {mood}: Error - {e}')
        
        if failed_playlists:
            print(f'\\nâš ï¸  {len(failed_playlists)} playlists may have issues:')
            for mood, playlist_id, error in failed_playlists:
                print(f'  - {mood} ({playlist_id}): {error}')
        else:
            print('\\nğŸ‰ All playlists are accessible!')
        "
        
    - name: Generate playlist report
      run: |
        echo "ğŸ“Š Generating playlist report..."
        python -c "
        from app_production import mood_playlists, mood_categories
        
        print('\\nğŸµ MoodTunes Playlist Report')
        print('=' * 40)
        print(f'Total Moods: {len(mood_playlists)}')
        print(f'Total Categories: {len(mood_categories)}')
        print()
        
        for category, data in mood_categories.items():
            print(f'{data[\"icon\"]} {category.title()}: {len(data[\"moods\"])} moods')
            for mood in data['moods']:
                playlist_id = mood_playlists[mood]
                print(f'  - {mood.title()}: {playlist_id}')
            print()
        "

  mood-coverage-report:
    name: Mood Coverage Analysis
    runs-on: ubuntu-latest
    needs: validate-playlists
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Analyze mood coverage
      run: |
        echo "ğŸ“ˆ Analyzing mood coverage and categories..."
        python -c "
        from app_production import mood_playlists, mood_categories, get_time_based_suggestions
        from collections import Counter
        import json
        
        # Analyze category distribution
        category_counts = {}
        for category, data in mood_categories.items():
            category_counts[category] = len(data['moods'])
        
        print('ğŸ“Š Category Distribution:')
        for category, count in sorted(category_counts.items()):
            percentage = (count / len(mood_playlists)) * 100
            print(f'  {category}: {count} moods ({percentage:.1f}%)')
        
        print('\\nğŸ• Time-based Suggestions Coverage:')
        # Test time suggestions multiple times to see variety
        all_suggestions = []
        for hour in range(0, 24):
            # Mock different hours (this is a simplified test)
            suggestions = get_time_based_suggestions()
            all_suggestions.extend(suggestions)
        
        suggestion_counts = Counter(all_suggestions)
        print(f'Total unique moods in time suggestions: {len(suggestion_counts)}')
        for mood, count in suggestion_counts.most_common():
            print(f'  {mood}: suggested {count} times')
        
        # Coverage metrics
        time_coverage = len(suggestion_counts) / len(mood_playlists) * 100
        print(f'\\nğŸ“ˆ Metrics:')
        print(f'  Time suggestion coverage: {time_coverage:.1f}%')
        print(f'  Average category size: {len(mood_playlists) / len(mood_categories):.1f} moods')
        print(f'  Total playlist variety: {len(set(mood_playlists.values()))} unique playlists')
        "